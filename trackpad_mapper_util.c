#include <pthread.h>
#include <Carbon/Carbon.h>
#include "MultitouchSupport.h"
#include "settings.h"

#define try(...) \
    if ((__VA_ARGS__) == -1) { \
        printf("`%s` failed", #__VA_ARGS__); \
        exit(1); \
    }

pthread_mutex_t mutex;
MTPoint fingerPosition = { 0, 0 };
MTPoint oldFingerPosition = { 0, 0 };
bool dragging = false;
CGMouseButton mouseButton = kCGMouseButtonLeft;
int32_t fingerID = 0;

CGEventSourceRef eventSource;

#define MAGIC_SELF_EVENT 12345

// emitting mouse events here increases sensitivity to finger
int trackpadCallback(
    MTDeviceRef device,
    MTTouch *data,
    size_t nFingers,
    double timestamp,
    size_t frame)
{
    if (nFingers > 0) {
        // remembers currently using which finger
        MTTouch *f = &data[0];
        for (int i = 0; i < nFingers; i++){
            if (data[i].fingerID == fingerID) {
                f = &data[i];
                break;
            }
        }
        fingerID = f->fingerID;

        // update position
        try(pthread_mutex_lock(&mutex));

        oldFingerPosition = fingerPosition;
        fingerPosition = map(
                f->normalizedVector.position.x, 1 - f->normalizedVector.position.y);

        try(pthread_mutex_unlock(&mutex));

        // emit event
        CGEventType type;
        if (dragging) {
            type = mouseButton == kCGMouseButtonLeft ?
                kCGEventLeftMouseDragged :
                kCGEventRightMouseDragged;
        } else {
            type = kCGEventMouseMoved;
        }
        CGPoint point = {
            .x = fingerPosition.x,
            .y = fingerPosition.y,
        };
        CGPoint delta = {
            .x = fingerPosition.x - oldFingerPosition.x,
            .y = fingerPosition.y - oldFingerPosition.y,
        };

        CGEventRef event = CGEventCreateMouseEvent(
                eventSource, type, point, mouseButton);
        // set magic number
        CGEventSetIntegerValueField(event, kCGEventSourceUserData, MAGIC_SELF_EVENT);
        // set other entries
        CGEventSetIntegerValueField(event, kCGMouseEventDeltaX, delta.x);
        CGEventSetIntegerValueField(event, kCGMouseEventDeltaY, delta.y);
        // 3 = touch / trackpad event
        CGEventSetIntegerValueField(event, kCGMouseEventSubtype, 3);

        CGEventPost(kCGHIDEventTap, event);
    }
    return 0;
}

// Filter all system generated mouseMoved / mouseDragged events and
// keep only those generated by us
CGEventRef updateCursor(
    CGEventTapProxy proxy,
    CGEventType type,
    CGEventRef event,
    void *reference)
{
    // Retrieve magic number
    int magic = CGEventGetIntegerValueField(event, kCGEventSourceUserData);
    switch (type) {
        case kCGEventRightMouseUp:
            mouseButton = kCGMouseButtonRight;
            dragging = false;
            break;
        case kCGEventRightMouseDown:
            mouseButton = kCGMouseButtonRight;
            dragging = true;
            break;
        case kCGEventLeftMouseUp:
            mouseButton = kCGMouseButtonLeft;
            dragging = false;
            break;
        case kCGEventLeftMouseDown:
            mouseButton = kCGMouseButtonLeft;
            dragging = true;
            break;
        default:
            if (magic != MAGIC_SELF_EVENT) {
                return NULL;
            }
    }
    return event;
}

bool check_privileges(void) {
    bool result;
    const void *keys[] = { kAXTrustedCheckOptionPrompt };
    const void *values[] = { kCFBooleanTrue };

    CFDictionaryRef options;
    options = CFDictionaryCreate(
            kCFAllocatorDefault,
            keys, values, sizeof(keys) / sizeof(*keys),
            &kCFCopyStringDictionaryKeyCallBacks,
            &kCFTypeDictionaryValueCallBacks);

    result = AXIsProcessTrustedWithOptions(options);
    CFRelease(options);

    return result;
}

int main(int argc, char** argv) {
    if (!check_privileges()) {
        printf("Requires accessbility privileges\n");
        return 1;
    }
    // init mutex
    try(pthread_mutex_init(&mutex, NULL));
    
    // start trackpad service
    MTDeviceRef dev = MTDeviceCreateDefault();
    MTRegisterContactFrameCallback(dev, (MTFrameCallbackFunction)trackpadCallback);
    MTDeviceStart(dev, 0);
    
    // CGEventTap loop
    eventSource = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);

    // cursor movement
    CGEventMask mask = 1 << kCGEventMouseMoved |
                       1 << kCGEventLeftMouseDragged |
                       1 << kCGEventRightMouseDragged |
                       1 << kCGEventRightMouseDown |
                       1 << kCGEventRightMouseUp |
                       1 << kCGEventLeftMouseDown |
                       1 << kCGEventLeftMouseUp;
    CFMachPortRef handle = CGEventTapCreate(
        kCGHIDEventTap,
        kCGHeadInsertEventTap,
        kCGEventTapOptionDefault,
        mask,
        updateCursor,
        NULL);
    CFRunLoopSourceRef runLoopSource = CFMachPortCreateRunLoopSource(
            kCFAllocatorDefault, handle, 0);
    CFRunLoopAddSource(CFRunLoopGetMain(), runLoopSource, kCFRunLoopCommonModes);
    
    CFRunLoopRun();
    return 0;
}
